<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Spring基础知识总结 | 扶邓松的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring简介优点 低侵入式设计，代码的污染极低。 独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。 Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。 Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。 Spring的ORM和DAO提供了与第三方持久层框">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring基础知识总结">
<meta property="og:url" content="http://yoursite.com/2019/07/18/Spring基础知识总结/index.html">
<meta property="og:site_name" content="扶邓松的个人博客">
<meta property="og:description" content="Spring简介优点 低侵入式设计，代码的污染极低。 独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。 Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。 Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。 Spring的ORM和DAO提供了与第三方持久层框">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://static.codeceo.com/images/2015/07/673670c9a34075831373b711cb8f21b7.png">
<meta property="og:updated_time" content="2019-07-26T13:33:26.609Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring基础知识总结">
<meta name="twitter:description" content="Spring简介优点 低侵入式设计，代码的污染极低。 独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。 Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。 Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。 Spring的ORM和DAO提供了与第三方持久层框">
<meta name="twitter:image" content="http://static.codeceo.com/images/2015/07/673670c9a34075831373b711cb8f21b7.png">
  
    <link rel="alternate" href="/atom.xml" title="扶邓松的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">扶邓松的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring基础知识总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/Spring基础知识总结/" class="article-date">
  <time datetime="2019-07-18T10:00:00.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring基础知识总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>低侵入式设计，代码的污染极低。</li>
<li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。</li>
<li>Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。</li>
<li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。</li>
<li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。</li>
<li>Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。</li>
</ul>
<h3 id="Spring框架结构"><a href="#Spring框架结构" class="headerlink" title="Spring框架结构"></a>Spring框架结构</h3><h3 id><a href="#" class="headerlink" title></a><img src="http://static.codeceo.com/images/2015/07/673670c9a34075831373b711cb8f21b7.png" alt="spring01"></h3><h3 id="Spring的体系结构。"><a href="#Spring的体系结构。" class="headerlink" title="Spring的体系结构。"></a>Spring的体系结构。</h3><ul>
<li><p>核心容器（Core Container）</p>
</li>
<li><ul>
<li>Spring-Core : 核心工具类</li>
<li>Spring-Beans:定义Bean的支持</li>
<li>Spring-Context:运行时容器 、 Spring-Contex-Support : 对第三方包的继承支持</li>
<li>Spring-Expression:使用表达式语言在运行时查找和操作对象</li>
</ul>
</li>
<li><p>切面（AOP、Aspects）</p>
</li>
<li><ul>
<li>Spring-AOP：基于代理的AOP支持</li>
<li>Spring-Aspects:基于AspectJ的AOP支持</li>
</ul>
</li>
<li><p>消息（Messaging）</p>
</li>
<li><ul>
<li>Spring-Messaging：对于消息架构和协议的支持</li>
</ul>
</li>
<li><p>网络（Web）</p>
</li>
<li><ul>
<li>Spring-Web: 提供基础的Web功能，在Web项目中提供Spring容器</li>
<li>Spring-Webmvc：提供基于servlet的Spring MVC</li>
<li>Spring-WebSocket：提供WebSocket功能</li>
<li>Spring-WebSocket-Portlet:提供Portlet环境支持</li>
</ul>
</li>
<li><p>数据访问\集成（Data Access\Integration）</p>
</li>
<li><ul>
<li>Spring-JDBC：提供JDBC访问数据库的支持</li>
<li>Spring-TX：提供编程式和声明式的事务支持</li>
<li>Spring-ORM：提供对对象\关系映射的支持</li>
<li>Spring-OXM：提供对象\xml映射的支持</li>
<li>Spring-JMS：提供对JMS的支持</li>
</ul>
</li>
</ul>
<h2 id="Spring的核心机制"><a href="#Spring的核心机制" class="headerlink" title="Spring的核心机制"></a>Spring的核心机制</h2><ul>
<li>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。</li>
<li>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。</li>
<li>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</li>
<li>依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指<strong>通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦</strong>。</li>
</ul>
<h3 id="使用构造器创建Bean实例"><a href="#使用构造器创建Bean实例" class="headerlink" title="使用构造器创建Bean实例"></a>使用构造器创建Bean实例</h3><ul>
<li><p>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。</p>
</li>
<li><p>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“personService</span>" <span class="attr">class</span>=<span class="string">"cn.test.bean.impl.PersonServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用静态工厂方法创建Bean"><a href="#使用静态工厂方法创建Bean" class="headerlink" title="使用静态工厂方法创建Bean"></a>使用静态工厂方法创建Bean</h3><ul>
<li><p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。</p>
</li>
<li><p>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用<code>&lt;constructor-arg.../&gt;</code>元素指定静态工厂方法的参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService"</span><span class="attr">class</span>=<span class="string">"com.test.factory.PersonServiceFactory"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">"createPersonService"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PersonService <span class="title">createPersonService</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="调用实例工厂方法创建Bean"><a href="#调用实例工厂方法创建Bean" class="headerlink" title="调用实例工厂方法创建Bean"></a>调用实例工厂方法创建Bean</h3><ul>
<li><p>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的<code>&lt;bean.../&gt;</code>元素无须class属性，配置实例工厂方法使用<code>factory-bean</code>指定工厂实例。采用实例工厂方法创建Bean的<code>&lt;bean.../&gt;</code>元素时需要指定如下两个属性：</p>
</li>
<li><p>factory-bean: 该属性的值为工厂Bean的id。</p>
</li>
<li><p>factory-method: 该属性指定实例工厂的工厂方法。</p>
</li>
<li><p>若调用实例工厂方法时需要传入参数，则使用<code>&lt;constructor-arg.../&gt;</code>元素确定参数值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“personServiceFactory</span>" <span class="attr">class</span>=<span class="string">"com.test.factory.PersonServiceFactory"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService"</span> <span class="attr">factory-bean</span>=<span class="string">“personServiceFactory</span>" <span class="attr">factory-method</span>=<span class="string">"createPersonService"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> PersonService <span class="title">createPersonService</span><span class="params">()</span></span>&#123; </span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Spring框架bean的作用域"><a href="#Spring框架bean的作用域" class="headerlink" title="Spring框架bean的作用域"></a>Spring框架bean的作用域</h3><ul>
<li>singleton : bean在每个Spring ioc 容器中只有一个实例。</li>
<li>prototype：一个bean的定义可以有多个实例。</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<h3 id="Spring框架中bean的生命周期。"><a href="#Spring框架中bean的生命周期。" class="headerlink" title="Spring框架中bean的生命周期。"></a>Spring框架中bean的生命周期。</h3><ul>
<li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>
<li>Spring根据bean的定义填充所有的属性。</li>
<li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>
<li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>
<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>
<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>
<li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>
<li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li>
</ul>
<h3 id="Spring的依赖注入"><a href="#Spring的依赖注入" class="headerlink" title="Spring的依赖注入"></a>Spring的依赖注入</h3><ul>
<li><p>set注入：set注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set注入有如下优点：</span><br><span class="line">与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。</span><br><span class="line">对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。</span><br><span class="line">尤其在某些成员变量可选的情况下，多参数的构造器更加笨重</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造注入：利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</span><br><span class="line">对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。</span><br><span class="line">依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在XML文件中同样不用<property>的形式，而是使用<constructor-arg>标签，ref属性同样指向其它<bean>标签的name属性。</bean></constructor-arg></property></p>
</li>
<li><p>静态工厂的方法注入：顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取。</p>
</li>
<li><p>实例工厂的方法注入：实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法。</p>
</li>
</ul>
<h3 id="Spring的注解支持"><a href="#Spring的注解支持" class="headerlink" title="Spring的注解支持"></a>Spring的注解支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 context:annotation-config/元素。</span><br><span class="line"></span><br><span class="line">Spring4.0增强的自动装配和精确装配</span><br><span class="line">	Spring提供了@Autowired注解来指定自动装配，@Autowired可以修饰setter方法、普通方法、实例变量和构造器等。当使用@Autowired标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了@Qualifier注解，通过使用@Qualifier，允许根据Bean的id来执行自动装配。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>注解</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>声明Bean</td>
<td>＠Component</td>
<td>组件，表明这个类是一个Bean</td>
<td>通常用于实体类</td>
</tr>
<tr>
<td>＠Service</td>
<td>在业务逻辑层使用（Service层）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠Repository</td>
<td>在数据访问层使用（DAO层）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠Controller</td>
<td>在展示层使用，控制器的声明</td>
<td></td>
<td></td>
</tr>
<tr>
<td>注入Bean</td>
<td>＠Autowired</td>
<td>注解在属性或set()上【推荐注解在属性上】</td>
<td>按byType自动注入可以与@Qualifier(name)联合使用，指定按byNAme自动注入</td>
</tr>
<tr>
<td>＠Resource</td>
<td>按ByName自动注入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠Inject</td>
<td>由JSR－２５０提供</td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置类</td>
<td>＠Configuration</td>
<td>声明当前类为配置类</td>
<td>相当于ｘｍｌ形式的Spring配置</td>
</tr>
<tr>
<td>＠Bean</td>
<td>声明方法的返回值是一个Bean（方法上）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠ComponentScan</td>
<td>用于对Component进行扫描并注册成Bean</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@EnableWebMvc</td>
<td>开启web MVC的配置支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@EnableConfigrationProperties</td>
<td>开启对@ConfigurationProperties注解配置Bean的支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@EnableJpaRepositories</td>
<td>开启对Spring Data JPA Repository的支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@EnableTransactionManagement</td>
<td>开启注解式事务的支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>@EnableCaching</td>
<td>开启注解式缓存的支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠EnableAspectJAutoProxy</td>
<td>开启Spring对AspectJ代理的支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AOP</td>
<td>＠Aspect</td>
<td>声明一个切面（类上）</td>
<td></td>
</tr>
<tr>
<td>@Order</td>
<td>指定切面的优先级</td>
<td>可缺省</td>
<td></td>
</tr>
<tr>
<td>＠PointCut</td>
<td>声明切点</td>
<td>在Java配置类中使用</td>
<td></td>
</tr>
<tr>
<td>＠Before</td>
<td>在方法执行之前执行（方法上）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠After</td>
<td>在方法执行之后执行（方法上）</td>
<td>被代理的方法抛出异常，@After标记的方法也会执行</td>
<td></td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>在方法正常执行之后执行（方法上）</td>
<td>被代理的方法抛出异常，@AfterReturning标记的方法不会执行</td>
<td></td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>在方法抛出异常后执行</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠Around</td>
<td>在方法执行之前以及之后执行（方法上）</td>
<td>可以修改被代理方法的返回值</td>
<td></td>
</tr>
<tr>
<td>＠Bean的属性支持</td>
<td>＠Scope</td>
<td>设置如何创建Bean实例</td>
<td>设置类型包括：Singleton：单例（默认模式）Protetype：每次调用创建一个新的beanRequest：给每个Http　request创建一个beanSession：给每个Http　session创建一个beanGlobalSession：给每个global　Http　session创建一个bean</td>
</tr>
<tr>
<td>＠StepSession</td>
<td>在Spring　Batch中还有涉及</td>
<td></td>
<td></td>
</tr>
<tr>
<td>＠PostConstruct</td>
<td>在构造函数执行之后执行（方法上）</td>
<td>由JSR-２５０提供，等价于xml配置文件中bean的initMethod</td>
<td></td>
</tr>
<tr>
<td>＠PreDestroy</td>
<td>在bean销毁前执行</td>
<td>由JSR-２５０提供，等价于xml配置文件中bean的destroyMethod</td>
<td></td>
</tr>
<tr>
<td>＠Value注解</td>
<td>＠Value[使用的是SpEL表达式]</td>
<td>注入普通字符</td>
<td>＠Value(“Winn”)String　name；</td>
</tr>
<tr>
<td>注入操作系统属性</td>
<td>＠Value(“#{systemProperties[‘os.name’]}”)String　osName；</td>
<td></td>
<td></td>
</tr>
<tr>
<td>注入表达式结果</td>
<td>＠Value(“#{T(java.lang.Math).random()*100}”)String randomNumber;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>注入其他bean属性的值</td>
<td>＠Value(“#{domeClass.name}”)String　name；</td>
<td></td>
<td></td>
</tr>
<tr>
<td>注入文件资源</td>
<td>＠Value(“classpath:com/blueStarWei/rsc/test.txt”) Resource file；</td>
<td></td>
<td></td>
</tr>
<tr>
<td>注入外部配置文件</td>
<td>＠Value(“${book.name}”) String　bookName； 还需要在类上添加＠PropertySource(“classpath:com/blueStarWei/rsc/test.txt”) 还需要配置一个PropertySourcesPlaceholderConfigurer的bean</td>
<td></td>
<td></td>
</tr>
<tr>
<td>环境切换</td>
<td>＠Profile</td>
<td>通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境（类或方法上）</td>
<td>在不同环境下使用不同的配置文件</td>
</tr>
<tr>
<td>＠Conditional</td>
<td>定义条件化的bean（方法上）</td>
<td>通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化</td>
<td></td>
</tr>
<tr>
<td>多线程</td>
<td>@EnableAsync</td>
<td>开启对异步任务的支持（配置类上）</td>
<td></td>
</tr>
<tr>
<td>@Async</td>
<td>声明异步任务（类或方法上）</td>
<td>如果注释在类上，则该类内所有的方法都是异步方法</td>
<td></td>
</tr>
<tr>
<td>计划任务相关</td>
<td>＠EnableScheduling</td>
<td>开启计划任务的支持（类上）</td>
<td>在配置类上使用</td>
</tr>
<tr>
<td>＠Scheduled</td>
<td>申明这是一个任务（方法上）</td>
<td>需要线开启计划任务的支持计划任务包括cron、fixDelay、fixRate等类型</td>
<td></td>
</tr>
<tr>
<td>测试相关</td>
<td>＠RunWith</td>
<td>运行器，Spring中通常用于对JUnit的支持</td>
<td>@RunWith(SpringJUnit4ClassRunner.class)</td>
</tr>
<tr>
<td>＠ContextConfiguration</td>
<td>加载配置ApplicationContext</td>
<td>classes属性用来加载配置类＠ContextConfiguration(classes={AppConfig.class})</td>
<td></td>
</tr>
<tr>
<td>事务</td>
<td>@Transactional</td>
<td>使用事务</td>
<td>属性 propagation用来指定事务的传播行为（默认传播行为Propagation.REQUIRED）属性isolation用来指定事务的隔离级别</td>
</tr>
<tr>
<td>补充</td>
<td>@Import</td>
<td>导入配置类</td>
<td></td>
</tr>
</tbody></table>
<h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>关于面向切面编程的一些术语：</p>
<ul>
<li><p>连接点（Joinpoint）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点.</p>
</li>
<li><p>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。</p>
</li>
<li><p>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有”around”、”before”和”after”等类型</p>
</li>
<li><p>Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.</p>
</li>
<li><p>Target(目标对象):代理的目标对象</p>
</li>
<li><p>Weaving(织入):是指把增强应用到目标对象来创建新的代理对象的过程.spring采用动态代理织入，而AspectJ采用编译期织入和类装在期织入</p>
</li>
<li><p>Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一、原理区别：</span><br><span class="line">java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</span><br><span class="line">而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</span><br><span class="line">1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP </span><br><span class="line">2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP </span><br><span class="line">3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</span><br><span class="line">如何强制使用CGLIB实现AOP？</span><br><span class="line"> （1）添加CGLIB库，SPRING_HOME/cglib/*.jar</span><br><span class="line"> （2）在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br><span class="line">JDK动态代理和CGLIB字节码生成的区别？</span><br><span class="line"> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类</span><br><span class="line"> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法,因为是继承，所以该类或方法		最好不要声明成final</span><br></pre></td></tr></table></figure>
</li>
<li><p>Aspect(切面): 是切入点和通知（引介）的结合，切面用于组织多个Advice，Advice放在切面中定义。</p>
<p>​</p>
</li>
</ul>
<h3 id="使用AspectJ实现AOP"><a href="#使用AspectJ实现AOP" class="headerlink" title="使用AspectJ实现AOP"></a>使用AspectJ实现AOP</h3><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。</p>
<p>AOP实现可分为两类：</p>
<ol>
<li>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。</li>
<li>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。</li>
</ol>
<p>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用五种类型的通知：</p>
<p>·        before：前置通知，在一个方法执行前被调用。</p>
<p>·        after: 在方法执行之后调用的通知，无论方法执行是否成功。</p>
<p>·        after-returning: 仅当方法成功完成后执行的通知。</p>
<p>·        after-throwing: 在方法抛出异常退出时执行的通知。</p>
<p>·        around: 在方法执行之前和之后调用的通知。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/Spring基础知识总结/" data-id="cjyk6cjji0004dgvak9lutaml" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/18/SpringMVC基础知识总结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SpringMVC基础知识总结
        
      </div>
    </a>
  
  
    <a href="/2019/07/17/NoSQL数据库Redis/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Redis基础</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/26/HTTP、TCP、UDP以及SOCKET之间的区别联系/">HTTP、TCP、UDP以及SOCKET之间的区别联系</a>
          </li>
        
          <li>
            <a href="/2019/07/26/ZooKeeper基础/">zooKeeper基础</a>
          </li>
        
          <li>
            <a href="/2019/07/20/SpringCloud基础架构搭建/">SpringCloud基础架构</a>
          </li>
        
          <li>
            <a href="/2019/07/18/SpringMVC基础知识总结/">SpringMVC基础知识总结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/Spring基础知识总结/">Spring基础知识总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 扶邓松<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>